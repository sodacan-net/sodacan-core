{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#more-details","title":"More Details","text":"<p>SodaCan Architecture SodaCan Module Language Guide SodaCan Module Language Reference SodaCan Module Developer's Guide</p> <p>Getting Started with SodaCan SodaCan Operations For SodaCan Source code developers</p>"},{"location":"#project-documentation","title":"Project Documentation","text":"<p>SodaCan Agent SodaCan API SodaCan Compiler SodaCan Message Structure SodaCan Module Structure SodaCan Module Runtime Top-level SodaCan Project Utility functions SodaCan RESTful API and web server</p>"},{"location":"adapters/","title":"Adapters","text":"<p>In general, adapter code is attached to a sodaCan <code>MODULE</code>. The adapter code has complete read access to the variables in the module. Custom subscription code can be safely single-threaded: SodaCan will call the custom code synchronously, one message at a time. A simple adapter module follows:</p> <pre><code>    MODULE lamp3\n        SUBSCRIBE livingRoom.lamp AS lamp\n        EXTERNAL someFunction\n        ON lamp\n            THEN someFunction\n</code></pre> <p>A slightly more complicated adapter module involves instances: If the message contains an instance, then the instance is also available to the adapter code through callback to SodaCan.</p> <pre><code>    MODULE lampAdapter[location]\n        SUBSCRIBE lamp[location] AS lamp\n        EXTERNAL someFunction\n        ON lamp\n            THEN someFunction[location]\n</code></pre> <p>For publishing messages, the custom code can't know if the <code>MODULE</code> it is attached to is in the middle of a cycle or not. The stimulus for sending a message is only known to the adapter code, not SodaCan. So, when an event is raised by adapter code, a message is published asynchronously: The custom code does this by calling back to SodaCan (actually the agent running that module) and asks it to publish a message to the topic and variable declared by the <code>PUBLISH</code> variable. </p> <p>Internally, normal publish actions are taken at the end of a cycle. However, for adapter code, the publication occurs immediately. If the adapter module limits its behavior to just calling adapter functions, this difference should be invisible.</p> <p>In some cases, especially when an existing driver is involved, SodaCan adapter code can be a simple \"wrapper\" adapter. That is, a small bit of adapter code that simply passes messages along to the real adapter code using, say, a TCP socket.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>SodaCan is designed as a collection of microservices with an infrastructure to support them. Decision-making microservices in Sodacan are called <code>Modules</code>. Microservices that interface with external systems and devices are called \"Message Adapters\". In general, SodaCan microservices have the following characteristics:</p> <ul> <li>Message Oriented</li> <li>Independently testable and deployable</li> <li>Loosely coupled</li> </ul> <p>Additionally, SodaCan modules are:</p> <ul> <li>Domain-specific</li> <li>Declarative</li> <li>Friendly to non-programmers</li> </ul> <p>Message adapters are technical components that - gather input, create messages, and put them on the message bus, or - send messages from the bus onto external systems</p> <p>The technology used by an adapter varies by adapter, but on one side of the adapter is usually the SodaCan message bus. The other side being whatever behavior is needed to interface to message, database, or similar.</p>"},{"location":"architecture/#message-oriented","title":"Message Oriented","text":"<p>A message oriented architecture, if taken to its extreme, means that there is a complete decoupling between components. SodaCan attempts to do just that. The cost of a message oriented architecture is that there is an overhead to using messages. An actual message is created by a producer, published to a broker (message bus) and subscribed to by zero or more consumers. In SodaCan terms, modules, which provide the decision making, and adapter modules, which interface to the outside world, are the end-nodes in a message-based system. A nice side-effect of this design is that the overall data-flow is relatively flat: components send messages to or receive messages from the message bus. The only minor exception is that some components may use local IO to access a datastore for persistence.</p>"},{"location":"architecture/#publish-subscribe","title":"Publish Subscribe","text":"<p>Components of this system communicate using publish/subscribe semantics. You should be at least a little familiar with  publish-subscribe design pattern before reading further. In short, publishing a message means making it available to an subscriber interested in the message. The publisher need not be concerned about the destination of a message. The dataflow though a component is always the same:</p> <pre><code>flowchart LR;\n    A[Message Bus] -. subscribe .-&gt; B[Component];\n    B[Component] -. publish .-&gt; A[Message Bus];</code></pre>"},{"location":"architecture/#module-testablility","title":"Module Testablility","text":"<p>Modules are 100% standalone with no dependencies on any other modules. Knowing this, the author of a module should not need to be concerned with anything other than what messages that module receives and what messages it produces. And, because it is message oriented, there is no restriction on where messages originate from (or where they go). A module does not need to be \"wired up\" at any time.</p> <p>To unit test a module only requires a collection of messages to be fed to the SodaCan runtime and a way to verify that the resulting messages, if any, contain the expected results. The message source will contain the module itself as well as any input messages.</p> <p>With the use of \"deployment mode\", a module can be integration tested in a \"live\" environment with no effect on the real live environment.</p>"},{"location":"architecture/#messages","title":"Messages","text":"<p>In SodaCan, <code>PUBLISH</code> variables are essentially messages waiting to be sent. And, <code>SUBSCRIBE</code> variables are messages waiting to be received. Messages are exchanged through what is called a topic which is defined in more detail below. Simply put, a topic groups together messages of a specific format. That format is then the topic name.</p> <p>All messages contain a <code>timestamp</code> which implies a temporal sequence for messages. Messages contain an \"offset\" attribute which uniquely describes each individual message within a topic.</p> <p>The producer is also identified in a message. Messages also contain a <code>key</code> and a <code>payload</code>, both of which are optional.</p>"},{"location":"architecture/#message-bus","title":"Message Bus","text":"<p>Abstractly, a message bus exits to exchange messages. Ignoring security, anyone can produce a message and anyone can consume messages. In SodaCan, the message bus is an implementation detail handled in the background. The modules that make up a system are unaware of the bus itself. Like a post office handles the logistics of getting a newspaper from its source (producer) to its destination(s) (consumer(s)). In a message bus architecture, the producer of a message as no control over who consumes that message. And, in general, the consumer has no control over who, how or when the messages it receives are produced. This is the essence of decoupling in a microservice architecture.</p> <p>In the following diagram, messages are produced by Modules A and C without any knowledge of where they will be consumed or even if they will be consumed.</p> <p><pre><code>flowchart BT;\n    A[Module A] -. publish .-&gt; B[Message Bus];\n    C[Module C] -. publish .-&gt; B[Message Bus];</code></pre> When Module D is added, it can consume messages from the message bus as it sees fit.</p> <pre><code>flowchart BT;\n    A[Module A] -. publish .-&gt; B[Message Bus];\n    C[Module C] -. publish .-&gt; B[Message Bus];\n    B[Message Bus] -. subscribe .-&gt; D[Module D];</code></pre>"},{"location":"architecture/#message-producer","title":"Message Producer","text":"<p>A <code>MODULE</code> that contains one or more <code>PUBLISH</code> statements is a message producer. Each <code>PUBLISH</code> variable is sent onto the message bus.</p>"},{"location":"architecture/#message-consumer","title":"Message Consumer","text":"<p>A <code>MODULE</code> that contains one or more <code>SUBSCRIBE</code> statements is a message consumer.  A module is only able to \"see\" the information it receives via message (or the passage of time). In SodaCan, there is no such thing as peeking into another module to find a value. So, it is important to ensure that information needed by a consumer arrives via message. </p>"},{"location":"architecture/#topology","title":"Topology","text":"<p>The underlying messaging technology will determine the topology of a working SodaCan installation and how application components are deployed. The following table show the application components and where each resides in different configurations:</p>"},{"location":"architecture/#stand-alone","title":"Stand-alone","text":"<p>A SodaCan stand-alone configuration is useful for simple demonstrations and some development. It uses no communication except for a web server and it would be difficult to connect to real devices. Persistence is periodically stored in a flat file in JSON format. No reliability guarantee of the data. Communication between modules and the message bus all occur in a single address space. Keep in mind that performance in this simple configuration will be very fast. But it won't scale well. Don't try to draw conclusions about performance from this configuration.</p>"},{"location":"architecture/#single-node","title":"Single-node","text":"<p>A Single-node configuration uses Apache Kafka in a more-or-less real configuration but has no redundancy and does not scale. All of the components are the same as a distributed configuration though communication between components may still be faster because they are all on the same node. For a smaller installation without the need for high-availability and fault tolerance, the single-node configuration may be sufficient. Almost all unit and integration testing will work fine in this configuration. The part that isn't covered will be specific to Kafka.</p>"},{"location":"architecture/#distributed","title":"Distributed","text":"<p>A distributed configuration also uses Apache Kafka but with multiple brokers and topic partitioning. This configuration provides the highest throughput, scalability and best reliability. The transition from single-node to a distributed configuration is possible without having to start-stop the system. However, it does require careful planning and execution.</p>"},{"location":"architecture/#system-components","title":"System Components","text":"<pre><code>---\ntitle: Dependencies\n---\nflowchart TB;\nsubgraph application\n  wp(Web Pages)\n  dc(Dev&lt;br/&gt;Controller)\n  style dc fill:#f9f,stroke:#000\n  ua(User App)\n  style ua fill:#f9f,stroke:#000\n  cli(Command&lt;br/&gt;Line&lt;br/&gt;Tool)\n  ag(Module Agent)\nend\nsubgraph IO\n  mod(Mode)\n  ss(State&lt;br/&gt;Store)\n  mb(Message&lt;br/&gt;Bus)\n  cl(Clock)\nend\nap(Sodacan API)\nco(Compiler)\nka(Kafka Admin)\nm(Module)\noa(O/S Admin)\nra(REST API)\nrt(Runtime)\nws(Web Server)\ncli --- ka\ncli -.Sodacan Admin.- ap\ncli --- oa\nag --- rt\nap --- mod\nrt --- mod\nrt -.Execute.- m\nrt -.Compile.- co\nmod --- cl\nmod --- mb\nra --- ws\nws --- ap\nua --- ap\ndc --- ra\ndc -.alternate.- ap\nwp -.static.- ws\nwp --- ra\nmb --- k\ncl --- rtc\ncl --- tc\nmod --- ss\nss --- mem\nmb --- mem\nss --- f\nsubgraph plugin\n  f(File)\n  k(Kafka)\n  tc(Testing&lt;br/&gt;Clock)\n  rtc(Real Clock)\n  mem(Memory)\nend\n</code></pre>"},{"location":"architecture/#sodacan-api","title":"SodaCan API","text":"<p>The SodaCan API provides a way to perform administrative, operational, and application functions. Many of its functions are passed through messages to other components including the SodaCan web server, the underlying Kafka system, and mostly to SodaCan agents. The API in SodaCan is separate from the RESTful API in the web browser. Both provide similar capabilities but the SodaCan API talks directly to the message bus whereas the RESTful API is, of course, HTML-based which in turn uses the SodaCan API. The RESTful API is useful when the SodaCan message bus is behind a firewall or where it is more practical to use an HTTP-based solution.</p>"},{"location":"architecture/#command-line-tool","title":"Command Line Tool","text":"<p>The SodaCan command line tool provides a number of administrative functions including stating and stopping the server(s), creating topics, compiling and deploying modules, creating and managing modes, etc. It uses the Sodacan API.</p>"},{"location":"architecture/#web-server","title":"Web Server","text":"<p>The web server provides the same capabilities as the command line tool but in a graphical format. It also includes a dashboard for monitoring a running system. It uses the SodaCan API. The web server is also what exposes the SodaCan RESTful API. SodaCan uses static web pages, which it serves, which in turn call the same APIs which remote applications can use independent of web page, subject to authentication and authorization.</p>"},{"location":"architecture/#message-bus_1","title":"Message Bus","text":"<p>The Message Bus is a wrapper around Apache Kafka. Kafka is accessed only through Kafka's client APIs. An existing Kafka (and Zookeeper) installation can be used if necessary. A docker-based Kafka installation is also usable but be certain to externalize the message storage. The message bus wrapper (in Java) is needed to support the stand alone configuration and for unit testing SodaCan core code. It also allows plugin of an alternate message bus although no such plugins are available in SodaCan, yet.</p> <p>The message bus in SodaCan is responsible for reliably storing messages for however long is needed. This is the primary means of storage in SodaCan. Messages are the official \"source of truth\" in SodaCan. The other data stores such as module persistence can be recovered by replaying messages. When the Message Bus is Kafka, each Kafka broker stores these messages close to where the broker is running. If Kafka is running with replica &gt; 1, then there will be multiple copies of messages on different brokers.</p> <p>If the stand alone configuration is used, then messages are not stored reliably.</p>"},{"location":"architecture/#module-agent","title":"Module Agent","text":"<p>Module agent(s) are the workhorse of SodaCan. These agents host one or more modules and provide the timer, clock, persistence, and interface to the Message Bus.</p>"},{"location":"architecture/#logging-agent","title":"Logging Agent","text":"Component stand-alone Single Node Distributed Command Line Tool The entire system runs inside the tool. WebServer N/A MessageBus N/A LoggingAgent N/A ModuleAgent N/A ModulePersistence N/A LoggingAgent N/A <p>The smallest configuration will have a single agent that runs all modules in all modes. The command line administrative tool </p>"},{"location":"architecture/#topic-structure","title":"Topic Structure","text":"<p>Each module has it's own topic. More specifically, topics are named as follows:</p> Component Description mode Deployment Mode. Not to be confused with any variables that happen to be named mode. domain The full domain name of the local SodaCan broker module The module name"},{"location":"architecture/#message-format","title":"Message Format","text":"<p>Messages are organized by topic as described above. Within a topic, individual messages contain these fields:</p> Field Location Description Offset internal A permanent incrementing non-repeating integer within the topic Timestamp internal When the message was published Producer internal The name of the producer (eg module) that gave rise to this message mode key Deployment Mode. Not to be confused with any variables that happen to be named mode. domain key The full domain name of the local SodaCan broker topic internal The original topic name may be the same as producer, and is usually the same as the name of the topic containing this message instance key The module's instance, if any variable key The variable (or event name) value value The value of the variable, if any"},{"location":"architecture/#message-delivery","title":"Message Delivery","text":"<p>When a message is published, it is immediately delivered to any subscribing consumers, baring hardware or infrastructure difficulties. If a consumer (module) is unavailable, the message will be delivered when the component is restored.</p> <p>Latency between a message being published and being consumed should be in the neighborhood of 1-20 milliseconds, depending on the underlying hardware. Any application that depends on faster delivery should seek another solution.</p>"},{"location":"architecture/#module-persistence","title":"Module Persistence","text":"<p>Since messages arrive at a module one by-one, it is important to maintain state within a module. For example, a lamp module might have a \"mode\" setting that determines how other messages are handled. The mode-setting message will have arrived sometime before subsequent messages are processed that need the value of the mode setting. In the following, the <code>mode</code> variable will have been set via message some time in the past. When midnight arrives, that variable will be needed. Between those two times, the module may be off-line (crashed, power failure, explicitly taken off-line, etc). So, when the module needs to be restored, the variables must also be restored. </p> <p><pre><code>    MODULE lamp1\n        SUBSCRIBE mode  {off, auto, on} \n        PUBLISH state {on,off}\n        AT midnight       // Turn off this light\n          AND mode.auto  // at midnight\n          THEN state=off  // if mode is auto\n</code></pre> Persistence is handled automatically by the infrastructure. Underneath is a directory structure with a text file that is used to save and restore module state for each module and instance.  Call a module snapshot.</p> <pre><code>    &lt;agent working directory&gt;\n        &lt;mode name&gt;\n            &lt;domain name&gt;\n                &lt;module name&gt;\n                    &lt;instanceName&gt;.scc.json\n</code></pre> <p>The content of the .scc.json file is a json representation of the module's variables, including the values, AST and source code of the module.</p> <p>Now, this .scc.json file is completely redundant. Why? Because the variables in the module instance were populated by messages... and only messages. And, the messages that were consumed by a module that resulted in  the variable's current values are still around (in the message bus)!  That means one way to restore the current state of a module is to simply replay the message stream into that module (the output of the module can be ignored during this recovery).</p> <p>So, the snapshot file is just there for performance reasons. It would take much longer to replay messages,  sequentially, in order to recover a module's state than to simply load state from an indexed database optimized for random access.</p> <p>The module agent creates a snapshot for the module periodically and stores it in the data store.</p> <p>The final aspect of module persistence is the module \"code\" itself. When a new version of a module is compiled and then deployed, it is published as a message which the agent hosting the module intercepts and replaces the existing module code. This has a very nice effect: the point at which a module was changed in the stream of messages it processes is preserved in the message stream. In other words, a full audit trail is created. It also means that there is no need to manually deploy new modules as they are created or modified. The flow of messages into a module might look like this:</p> <pre><code>flowchart TB;\n   subgraph MB[Message Bus]\n        direction LR\n        a[variable a] -.-&gt; \n        b[variable b] -.-&gt; \n        c[module update] -.-&gt; \n        d[variable c];\n   end\n    MB --&gt; MA\n   subgraph MA[Module Agent]\n        direction TB\n        e[module]&lt;-- Save/Restore --&gt;ds[data store]\n    end\n</code></pre> <p>So, the module code itself is also stored in this data store under the special variable name <code>%%code%%</code></p> <p>The SodaCan agent is free to completely remove rarely used modules from memory and restore the module's code and variables as messages arrive.</p>"},{"location":"architecture/#infrastructure","title":"Infrastructure","text":""},{"location":"architecture/#module-deployment","title":"Module deployment","text":"<p>Each module and adapter is deployed as an independent program on a host computer. </p> <p>The SodaCan command line interface provides all the information needed to start and run a module or an adapter module. In the case of an adapter module, it is often desired that that module be deployed to a specific host since it may have code that interacts with one or more devices connected to that host.</p> <p>In other respects, modules are deployed randomly to available SodaCan agents.</p>"},{"location":"architecture/#web-application","title":"Web Application","text":"<p>The sodaCan web application has several top-level windows:</p> <ul> <li>User Account - maintain the user's account, login page, etc</li> <li>Administration - Create users, maintain topics, </li> <li>Operations - Monitor message bus storage and message traffic</li> <li>Application Console - Modules, buttons, etc </li> </ul> <p>See Web Server for more details.</p>"},{"location":"architecture/#comparisons-to-conventional-approaches","title":"Comparisons to Conventional Approaches","text":"<p>Modules can be thought of a Java/C++ class definition but in reverse. The term \"static\" is used to distinguish class-wide variables whereas SodaCan makes variables without any indication otherwise, a static. Conversely, when referring to an instance variable, SodaCan requires what may look like an array reference to instance variables.</p> <p>Module Persistence in SodaCan is not unlike systems such as Apache Flink which, like SodaCan, stores persistent data with the end-point rather than having to connect to a database. This approach, along with messaging, virtually eliminates the need to deal with database concurrency, locking and similar problems.</p> <p>The module language is line oriented, similar to Python but without its indent sensitivity. Unlike many languages in use today, SodaCan module language is case insensitive.</p> <p>Aliases are used in modules and they look like a SQL alias:</p> <p><pre><code>    SELECT primaryPhoneNumber AS ppn FROM ...\n</code></pre> In a SodaCan Module</p> <pre><code>    MODULE lamp1\n        PUBLISH mydomain.verylongname AS shortName\n        ...\n</code></pre> <p>They also work the same as in SQL and follow the expression or variable as in SQL.</p> <p>The module language is closer to a domain-specific language than a true programming language for several reasons:</p> <ul> <li>It has very little technical chatter. Only a few very broad data types. No such thing as int, int_32, BigDecimal, etc. Just a number (Sodacan uses the term DECIMAL).</li> <li>The hierarchy is shallow. There are modules and variables within modules and that's about it. Traditional <code>IF</code> statements and code blocks (begin-end-style) are not used to keep the module shallow. This is similar to the way some rule languages control the depth of statements.</li> <li>Invocation is different from traditional programming languages. No such thing as a function or method call. When a message arrives in a module, it is immediately stored in a variable. This activates the module for one cycle. The module then waits for the next message to arrive. This means that open/close/loops etc are unnecessary.</li> </ul> <p>The <code>THEN</code> statement might seem novel. If there is more than one thing to do as a consequence of a conditional expression, then the <code>THEN</code> is repeated.</p> <pre><code>        ...\n        THEN do the first thing\n        THEN do the second thing\n</code></pre> <p>This extra bit of typing (THEN) eliminates the need for expression separators such as a semi-colon.</p>"},{"location":"developer/","title":"Developer Guide","text":"<p>This guide covers Module Development. It will probably help to first get a general overview by reading the architecture document. Also, this document frequently refers to modules which are described in more detail in the language guide and language reference documents.</p>"},{"location":"developer/#setting-up-a-development-environment","title":"Setting up a Development Environment","text":"<p>If you are starting from scratch then see the gettingStarted document to learn how to setup a SodaCan installation. </p> <p>If you have a SodaCan implementation already running, perhaps even a live on, then the easiest way to get started is by creating a mode. This gives you a sandbox to play in without affecting the live application.</p> <p>The remainder of this guide is based on having a Linux command-line.</p>"},{"location":"gettingStarted/","title":"Getting Started","text":"<p>This guide will show you how to get a Sodacan installation up and running. It will be a single </p>"},{"location":"gettingStarted/#docker-container","title":"Docker Container","text":""},{"location":"gettingStarted/#linux-installation","title":"Linux Installation","text":""},{"location":"gettingStarted/#windows-installation","title":"Windows installation","text":""},{"location":"gettingStarted/#initial-configuration","title":"Initial Configuration","text":"<p>Using the command line tool, you can start up the SodaCan message bus (broker).</p>"},{"location":"internals/","title":"SodaCan Internals","text":"<p>This document describes how SodaCan source code is maintained and provides a closer look at the various system components. The reader should be familiar with:</p> <ul> <li>Java 11+</li> <li>Apache Maven</li> <li>Apache Kafka and publish-subscribe in general</li> <li>SodaCan Architecture</li> <li>The SodaCan Module Language</li> </ul>"},{"location":"languageGuide/","title":"SodaCan Module Language Guide","text":""},{"location":"languageGuide/#topics-and-variables","title":"Topics and Variables","text":"<p>In SodaCan, all topics, and therefore, all messages must be formally defined before they can be used. Furthermore, all variaable*carried by messages in a topic must be defined as well. </p> <p>A topic defines a schema (or format) of messages for a specific purpose. You can think of a topic as a channel for information flow of similarly formatted messages. Once defined, a topic usually lasts forever, or until manually deleted.</p> <p>In a simple configuration topics can be created close to where they are commonly published. </p> <pre><code>    MODULE lamp1Control\n        PUBLISH livingRoom.lamp1 {off,on} AS lamp1\n\n        ...\n            THEN lamp1=on\n</code></pre> <p>In the example above, the topic <code>livingRoom</code> and its one variable <code>lamp1</code> are created automatically with the declaration of the <code>PUBLISH</code> variable. The module is then free to publish to that topic immediately as shown in the example. In this case, <code>lamp1.on</code> causes the on value to be published.</p> <p>But this approach is somewhat restrictive because one module seems to own the topic even though the topic in fact is defined globally. </p> <p>We can make this much tidier if we create a separate module that defines all or at least some of the topics and variables needed. Nothing else changes in either the producer or consumer. However, a neutral module can be thought of at the owner of the declaration thus allowing the other modules to come and go.</p> <pre><code>    MODULE livingRoomVariables\n        PUBLISH livingRoom.lamp1 {off,on}\n        // No other logic in this module\n</code></pre> <p>In the above, \"livingRoom\" is the topic and \"lamp1\" is a variable that will be exchanged via this topic. The <code>{off,on}</code> syntax means that the variable will hold an enumerated value of either \"on\" or \"off\". </p> <p>Syntactic Sugar: SodaCan blurs the lines between string literals and identifiers. For example, no quotes are needed in the list of possible values of an enumerated variable. Likewise, the identifier expression <code>variable.value</code> is a shortcut. In <code>ON</code> and <code>WHEN</code> statements, it means the same as <code>variable == \"value\"</code> (true if variable equals the value). In a <code>THEN</code> statement, it means the same as <code>variable = \"value\"</code> (assign \"value\" to variable). </p> <p>Next, we define a module that produces a message in this topic. In this case, the message is conveying the state of lamp1 as \"on\" in a message to the named topic.</p> <pre><code>    MODULE button23\n        PUBLISH livingRoom.lamp1 {on,off} AS lamp\n        ...\n        ON &lt;some condition&gt;\n            THEN lamp=on\n</code></pre> <p>And, a consumer module interested in this kind of message:</p> <pre><code>    MODULE lamp1\n        SUBSCRIBE livingRoom.lamp1 AS lamp\n        ON lamp\n        AND lamp==on\n            THEN &lt;do something&gt;\n</code></pre> <p>A <code>PUBLISH</code> declaration has behavior in addition to defining a topic and variable. When the module changes the value of a PUBLISH variable, that variable will be automatically published at the end of the cycle.</p> <p>A <code>SUBSCRIBE</code> variable will automatically subscribe to messages with that topic and variable. When a message arrives, the value of that variable will be stored in the module. Then, any <code>ON</code> statements matching that variable will be executed.</p> <p>Declaring both a publish and subscribe for the same variable will cause a compile error.</p> <p>You don't have to be specific about the contents of the message. Here's an example of an event called bedtime. It has no value component. So the ON statement can be equally brief:</p> <p><pre><code>    MODULE lamp1\n        SUBSCRIBE bedtime\n        ...\n        ON bedtime\n            THEN &lt;do something&gt;\n</code></pre> When constraints are specified on a SUBSCRIBE statement, it provides a bit more clarity about the nature of the incoming message but it also provides some shortcuts that are useful in subsequent statements. </p> <p><pre><code>    MODULE lamp1\n        SUBSCRIBE livingRoom.lamp1 {on,off} AS lamp\n        ON lamp.on\n            THEN &lt;do something&gt;\n        ON lamp.off\n            THEN &lt;do something else&gt;\n</code></pre> In this example, <code>ON lamp.on</code> and <code>ON lamp.off</code> mean the same thing as</p> <p><pre><code>    ON lamp\n        AND lamp==on\n</code></pre> that was used in the first SUBSCRIBE example above. The SUBSCRIBE </p>"},{"location":"languageGuide/#module-behavior","title":"Module behavior","text":"<p>A module waits quietly for either the passage of time or a message to arrive. If two or more messages arrive at the same time, one is chosen to go first. At that point, the list of <code>AT</code> (in the case of the passage of time) or <code>ON</code> (the arrival of a message) statements is considered, one at a time, in the order which they are declared, until one matches. The <code>THEN</code> statement(s) of the corresponding <code>ON</code> or <code>AT</code> is then executed. At that point, no further checks are made of the <code>AT</code>s and <code>ON</code>s. Each message or passage of time that is processed by a module is called a <code>cycle</code>.</p> <p>Processing then continues to the <code>WHEN</code> statements. These <code>WHEN</code> statements are not tied to any message in particular but they do react to changes made from the <code>THEN</code>s executed above. <code>WHEN</code> statements are optional but can greatly improve the maintainability of a module. First, a bad example, without using a <code>WHEN</code>:</p> <p><pre><code>    MODULE lamp1\n        SUBSCRIBE mode {off,auto,on}    \n        SUBSCRIBE event {toggle}\n        PUBLISH state {on,off}\n        AT midnight ON Fridays   // If it's midnight Friday\n          AND mode==auto        // And auto mode is on\n          THEN state=on             // set the lamp state to on\n    -&gt;    THEN log(\"Lamp is on\")    // Say so\n        AT sunset ON Thursdays   // If it's sunset on Thursdays\n          AND mode==auto        // and in auto mode\n          THEN state=on             // set lamp state to on\n    -&gt;    THEN log(\"Lamp is on\")    // Say so\n</code></pre> The \"lamp is on\" message is duplicated in the example above. </p> <p>We can fix this problem by using a <code>WHEN</code>in the example below. It will send a message regardless of which condition caused the state variable to change.</p> <p><pre><code>    MODULE lamp1\n        SUBSCRIBE mode {off,auto,on}    \n        SUBSCRIBE event {toggle}\n        PUBLISH state {on,off}\n        AT midnight ON Fridays   // If it's midnight Friday\n          AND mode==auto        // And auto mode is on\n          THEN state=on             // set the lamp state to on\n        AT sunset ON Thursdays   // If it's sunset on Thursdays\n          AND mode==auto        // and in auto mode\n          THEN state=on             // set lamp state to on\n    -&gt;  WHEN state==on              // If state is on\n          THEN log(\"Lamp is on\")    // say so.\n</code></pre> A <code>WHEN</code> only executes when the stated variable changes during a cycle. In the example above, if the state variable was already <code>on</code> then the <code>WHEN</code> statement will have no effect.</p> <p>The passage of time may not trigger any <code>ON</code> statements. That's normal. However, for messages, if no matching <code>ON</code> statement is found, then an error is thrown. Why? When a <code>module</code> subscribes to a particular topic, it declares its intent to deal with that message. If that doesn't happen, there's a problem: Either the <code>SUBSCRIBE</code> is wrong or the <code>ON</code>s are wrong or missing. </p>"},{"location":"languageGuide/#module-instance","title":"Module Instance","text":"<p>The examples so far are typically called lamp1, lamp2, etc. suggesting that a different module definition is needed for each device, even if the behavior of all of the devices so numbered are identical. An alternate is to define a module with instances. That is simple enough. Here is an example:</p> <p><pre><code>    MODULE lamp[location]\n        SUBSCRIBE mode[location] {off,auto,on}  \n        ...\n</code></pre> One module definition that handles all devices of a certain type.</p> <p>In this example, we made the following changes:</p> <ol> <li>Change the name of the module to <code>lamp</code> (this just looks cleaner, SodaCan doesn't care what you call a module as long as it is unique),</li> <li>Add the square brackets on the module line. This indicates that the module supports multiple instances. </li> <li>The name of a variable in the square brackets will be used to differentiate between different instances. </li> <li>It also means that messages we want to subscribe to must specify the location.  For example, another module that represents an individual button will need to publish a message that contains the location in addition to naming the variable to publish.</li> </ol> <p>Here is an over-simplified example of an individual button that is not an instance-based module. But you'll see that when it is ready to publish an event, the message will specify the location. In this case, \"hallway\".</p> <pre><code>    MODULE button3                  // A specific button\n        PUBLISH mode[location] {off,auto,on}\n        ...\n            THEN mode[\"hallway\"]=auto\n</code></pre> <p>If a module can be useful for many different devices but the behavior of each device is the same, then rather than making copies of the module with a slight name change, the module can be written to have module instances. When a module has instances, a mechanism is needed to create and keep track of such instances. Here is an example of a module that has instances. In this case, location is what differentiates each instance. And you'll notice that the <code>SUBSCRIBE</code> statement shown is qualified by the name of the instance. In other words, that subscription will listen for messages by location (with a variable name of <code>event</code>.</p> <p><pre><code>    MODULE lamp[location]\n        SUBSCRIBE event[location] {toggle}\n        ...\n        ON event==toggle\n        ...\n</code></pre> Instance creation is done by the command-line interface, the SodacanAPI or the browser-based control panel. You cannot create an instance from a module. However, the creation process, as usual, is done via message and we can be notified after the new instance is created: For that, you simply subscribe to the instance event. In this case, named \"location\". This event is sent to the module itself, not an instance.</p> <pre><code>    MODULE lamp[location]\n        SUBSCRIBE state[location] {off,on}\n        SUBSCRIBE location  // Respond to a new instance being created\n        ...\n        ON event==toggle\n        ...\n        ON location         // Respond to a new instance being created\n            THEN state=off\n            THEN print(location)\n</code></pre> <p>Now, a module can also keep and publish variables and messages module-wide. Think of the module as having a special instance that represents the whole module (A 'static' variable in some languages). But there's a problem: SodaCan never allows peeking into another module which means no peeking into another instance. To solve this problem, we simply send a hidden message from one instance to another including from the top-level instance to it's instances. This is all handled transaparently.</p> <p>Why so strict even in this situation? Because all instances of one module, including the top-level module, don't necessarily run in the same agent and maybe not even the same server. </p> <p>This approach works great when the top-level module makes a change that needs to be propagated to the children.  However, children to parent is not so obvious. Basically, this should be avoided unless the purpose is to collect statistics such as a count. From an instance, in the following. When the 'count` variable is modified, it is broadcast, as usual. </p> <pre><code>    MODULE lamp[location]\n        SUBSCRIBE state[location] {off,on}\n        SUBSCRIBE new.location    // Respond to a new instance being created\n        PUBLISH count 0           // published by the top-level module\n        SUBSCRIBE count[location]  // received by each instance\n        ON new.location\n            THEN count++\n        ...\n</code></pre>"},{"location":"languageGuide/#module-time","title":"Module Time","text":"<p>Detecting the passage of time is often important for automation problems. Within a module, the <code>AT</code> statement demonstrates the need for time based events, however, the infrastructure has the responsibility to interpret the requirements specified in a module and respond accordingly. And do it efficiently. One particularly complex aspect is being able to reproduce the passage of time in the future. In other words, we need to be able to look back in time and see that an <code>AT</code> event was actually triggered.  Conceptually, it looks like this (but don't try this at home). The lines with * are imaginary.</p> <pre><code>    MODULE lamp\n        *PUBLISH AtNoonOnFridays\n        ...\n        AT noon ON Fridays // Raise an event at noon on Fridays\n            *THEN activate(AtNoonOnFridays)\n            THEN ... what happens at noon on Fridays\n        *ON AtNoonOnFridays\n            *THEN ... what happens at noon on Fridays\n</code></pre> <p>Here's how this works in Sodacan: Unlike <code>ON</code> statements, which respond to explicit messages, <code>AT</code>statements are simply watching a clock looking for a match. To make these time-based events auditable and reproducible, the <code>AT</code> statements do watch the clock, but when one matches, it doesn't take action directly. Rather, a special message is sent to the module (itself) which then reacts as if it were an <code>ON</code> statement (This special message is invisible to the module author).</p> <ol> <li>\"AT noon ON Fridays\" matches the current time (it is noon and it is a Friday). </li> <li>The agent running the module constructs and sends a special message with the id of the matching <code>AT</code> statement. </li> <li>The special message is then processed as usual a moment later. Should the module currently be busy with a different message, then the special message will be processes after that one is done. At this point, <code>ON</code> message flow and <code>AT</code> message flow have been synchronized.</li> <li>When the special message is processed but the module, the <code>THEN</code> statement of the corresponding <code>AT</code> is executed. If there is a <code>WHEN</code> statement as part of the <code>AT</code> statement, it is also evaluated and may result in the special message being ignored.</li> <li>At this point, the module can go back to listening for new messages.</li> </ol> <p>Then, when needed, there is a complete audit trail in the message stream including hard <code>ON</code> events and timed <code>AT</code> events in the order in which they were processed.</p> <p>Race Condition (not a bug): The special message originates from an instance of the module which may be different from the instance of the module when the special message is processed, due to an intervening update to the module. The time gap is very small and their are most likely no ill effects with one exception: If updating a module results in a deletion of the AT statement, then the special message has nothing to match and will simply be dropped. It would be nice to insure that the special message could synchronously get in front of the queue, but that's not how message serialization works.</p>"},{"location":"languageGuide/#module-instance-time","title":"Module Instance Time","text":"<p>A slight complication in modules involves <code>AT</code> statements. If a module is declared as having an instance key and one ore more <code>AT</code> statements, such as:</p> <pre><code>    MODULE lamp[location]\n        ...\n        AT noon ON fridays\n            THEN ...\n</code></pre> <p>that means that there is actually one module per instance. And that means that if a time event is triggered, it will be sent to each \"instance\" of the module. And that may be exactly what is desired. For example, at the time of the time event, the special message is sent to all known instances at that time. Looking back in time, it will be obvious that a newly added instance would not have received the special message.</p>"},{"location":"languageGuide/#module-timers","title":"Module Timers","text":"<p>A timer is used when an action is to be taken in the future. And in many cases, one should be able to cancel or reset the timer. Here's an example:</p> <pre><code>    MODULE lamp1\n        ...\n        SUBSCRIBE state {off, on}\n        SUBSCRIBE livingRoom.motion AS motion\n        TIMER offTimer 30 minutes\n        ...\n        ON offTimer                 // If we get a message from the offTimer\n            THEN state=off              // Turn the light off\n        ON state==on                    // When state becomes on    \n            THEN offTimer=start         // Set a timer to turn it off\n        ON motion                       // On motion, reset the timer\n            THEN offTimer=reset\n        WHEN state==off                 // When lamp1 goes off, time is no longer needed\n            THEN offTimer=cancel\n</code></pre> <p>This example is simplified but it does explain the basic timer mechanism.</p> <p>What is actually happening? The <code>ON state.on</code> is saying: When the state variable transitions to  <code>on</code>, do the <code>THEN</code> statement that follows it. The <code>THEN</code> statement says to publish the <code>offTimer</code> message, but not immediately. Rather, SodaCan should wait for 30 minutes before doing so. The SodaCan agent for this module sets up a timer that will send a message to the module (itself) which will behave like any other message. It is perfectly OK to send a message you yourself. The the offTimer message is received, we have an <code>ON state.on</code> that picks it up and its <code>THEN</code> says to set the <code>state</code> to <code>off</code>.</p> <p>You'll notice a subtlety in the module compiler: the keyword <code>ON</code> begins a statement but it is no longer a keyword within the statement so you are free to use a state name such as <code>on</code> without conflict.  </p> <p>Because this timer publishes a real message, some other module could also subscribe to the message and take some unrelated action to the offTimer message goes off (separate from the state.off and .on messages). This message also joins the other messages in the topic which forms the historical audit log and maintains the sequential nature of message processing (no side effects).</p> <p>If for any reason the state is already \"off\" when the <code>OffTimer</code> message is processed, then the <code>state.off</code> action has no effect. If the state does transition to off, then any <code>WHEN</code>s in the module that react to that state change will trigger as usual.</p>"},{"location":"languageGuide/#module-processing-cycle","title":"Module Processing Cycle","text":"<p><code>ON</code> and <code>WHEN</code> statements may seem to work the same way. While it is true that the contents of the statement can look the same, the behavior is very different. During a processing cycle, the first 'AT' to match a change in the module state \"wins\" and all other <code>AT</code>s are ignored for that cycle. Conversely, all of the <code>WHEN</code>s that match during that same cycle are executed. </p> <p>In a procedural language, the <code>ON</code>s are like a series of <code>IF THEN ELSE</code> statements and the <code>WHEN</code>s are like a series of <code>IF THEN</code> statements following the <code>IF THEN ELSE</code> statements.</p>"},{"location":"languageGuide/#module-instance-topic-persistence","title":"Module Instance Topic Persistence","text":"<p>How does the SodaCan agent responsible for that module determine all of the module instances to broadcast to when this happens? A separate, parallel to the module, topic is created for each module which contains instances. This topic can be replayed to get the list of topics. There is only one entry per instance of the module that have been created. The following contains the format of messages in this topic all relevant data, the instance name, is in the key:</p> Key Component Description instance The instance key (for example, location of a light switch) <p>This approach is very efficient and does not cause any concurrency issues. </p>"},{"location":"languageGuide/#message-variable-duality","title":"Message-Variable Duality","text":"<p>In SodaCan, a variable defined in a module can be the source or destination for messages. When a message arrives, it is immediately stored in the named variable thus making it available to the module. In the following example, lamp1 is interested in the state of switch 1.</p> <p><pre><code>MODULE lamp1\n    SUBSCRIBE switch1.state {on,off}\n    ...\n    ON switch1.state==on\n        THEN ...\n</code></pre> Behind the scenes, SodaCan consumes a message and makes a note that its value has changed. In that case, it signals an event which the <code>ON</code> statements in the module will react to. </p> <p>The publishing side is similar. A <code>PUBLISH</code> variable is a message-in-waiting. Once a processing cycle is completed, <code>PUBLISH</code> variables that have been modified will be published.</p> <pre><code>MODULE switch1\n    PUBLISH state {on,off}\n    ...\n    ON ...\n        THEN state==on      // Set the state to on\n</code></pre> <p>In the background, the SodaCan agent monitors each <code>PUBLISH</code> variable and, if any changes are made to it by any of the module's <code>THEN</code> statements, a message will be published containing that variable. In this example, <code>state</code> is the variable so the message will be published as <code>switch1.state</code> with a value of <code>on</code>.</p> <p>Semantics: You cannot <code>SUBSCRIBE</code> and <code>PUBLISH</code> the same variable. </p> <p>The message causing the current value of a variable remains with the variable. This makes it easy to access meta-information such as when the message was sent:</p> <p><pre><code>MODULE lamp1\n    SUBSCRIBE switch1.state {on,off}\n    ...\n    ON switch1.state==on\n        *THEN system.log#info = switch1.state#timestamp\n</code></pre> *which says: \"send the timestamp of the message that populated <code>switch1.state</code> to the system log\".</p>"},{"location":"languageGuide/#module-instantiation","title":"Module Instantiation","text":"<p>In simple configurations, there may only be a single instance of each type of module. One living room lamp, one living room light switch, etc. In this case, messages will have an empty <code>key</code> attribute.  Other modules can be configured to handle a class of devices. For example, an organization might have a single lighting configuration which is used in all (or most) locations. Each office, for example, could behave the same but independent of other offices. In this case, the `'key' attribute of a message will contain the office (or location) name. Not much changes when a module is representing a class of devices rather than a single device. The module name would normally change. Instead of</p> <pre><code>    MODULE JoesOfficeLight\n</code></pre> <p>a more appropriate module name in this case will be</p> <p><pre><code>    MODULE OficeLight[location]\n</code></pre> which says there is a single office light class of module but that a separate instances of the module are created for each location. Of course in this case we also need to make sure our variables are separated by location. </p> <p><pre><code>    MODULE OficeLight[location]\n        PUBLISH state[location] {on,off}\n</code></pre> which tells SodaCan that the <code>state</code> variable is separate for each location.</p> <p>While the state variable (and consequently messages) are per-location, we might need other variables that apply to the entire class. Consider a company that has a policy of putting all lights into auto mode at a certain time of day requiring motion detecting for the light to remain on. That time is set company-wide. In this case we would like to send a single message to the \"OfficeLight\" module with the time all offices should go into auto mode. </p> <p><pre><code>    MODULE OficeLight[location]\n        SUBSCRIBE autoModeOnTime 00:00\n        PUBLISH state[location] {on,off}\n</code></pre> Notice that the <code>autoModeOnTime</code> variable has no key associated with it. A subsequent <code>AT statement</code> will refer to <code>autoModeOnTime</code>, without a key qualifier.</p> <pre><code>    MODULE OficeLight[location]\n        SUBSCRIBE autoModeOnTime 00:00\n        PUBLISH mode[location] {auto,manual}\n        PUBLISH state[location] {on,off}\n        AT autoModeOnTime\n            THEN mode[location]=auto\n        ...\n</code></pre>"},{"location":"languageGuide/#adapters","title":"Adapters","text":"<p>A SodaCan adapter is an end node in a SodaCan implementation. There are two primary types of adapter: message consumer and message producer. However, adapters can also be both a consumer and producer at the same time.  The following is a very simple interaction between a lamp and a button and a module that controls the behavior of the lamp (on or off). A real-world example would likely have additional capabilities but we keep it simple here:</p> <p><pre><code>sequenceDiagram\n    buttonAdapter-&gt;&gt;messageBus: button.press\n    messageBus-&gt;&gt;lampModule: button.press\n    lampModule-&gt;&gt;messageBus: lamp=on\n    messageBus-&gt;&gt;lampAdapter: lamp=on\n</code></pre> Flow of control: 1. <code>buttonAdapter</code> running on a microcontroller such as a Raspberry PI, monitors a digital in pin and when it goes positive (ignoring debounce logic), a message is published to the SodaCan <code>messageBus</code>. 2. The message is delivered to the <code>lampModule</code> which has subscribed to this type of message. 3. The <code>lampModule</code> determines if the button press is and off or on transition (it keeps track of the state of the lamp). When the state of the lamp in the <code>lampModule</code> changes, another message containing the new state is published to the <code>messageBus</code>. 4. The <code>lampAdapter</code>, running on a microcontroller subscribes to lamp's state message and upon receipt of this message sets a digital output pin high or low depending on the content of the message.</p> <p>If there is no need for logic in the lampModule, then it can be eliminated and the message published by the button read directly by the adapter module, like this:</p> <pre><code>sequenceDiagram\n    buttonAdapter-&gt;&gt;messageBus: lamp=on\n    messageBus-&gt;&gt;lampAdapter: lamp=on\n</code></pre> <p>Technically, an adapter is really just another module that has a bit of low-level code attached to it. It is also may be tied to a specific host if necessary. The low-level code (C, Java, etc) handles the details of device access: DIGITAL IN, OUT, SPI, D-A, A-D, etc. It also can do database IO or whatever else one can imagine. In the example below, the adapter module waits for a message about the state of the <code>lamp</code>. As usual, the <code>ON</code> detects the message, updates the variable with the new value and <code>THEN</code> makes a function call:</p> <p><pre><code>    MODULE lamp3\n        SUBSCRIBE livingRoom.lamp AS lamp\n        EXTERNAL someFunction\n        ON lamp\n            THEN someFunction\n</code></pre> The function in the custom code attached to the module can then access any variables in the module. When the <code>someFunction</code> function call returns, the cycle is complete. The module then waits for the next message.</p>"},{"location":"languageGuide/#message-persistence","title":"Message Persistence","text":"<p>When a message is produced, it takes on a life of its own; Neither belonging to the producer nor to any of its potential consumers. At that point, the message is owned and stored (persisted) by the message bus.  There is no sure-fire way for SodaCan to know when a message has been completely consumed. For example, a module that might consume a particular type of message  may not exist yet. If resources were infinite, there is no reason SodaCan would need to recover space used by any messages. The messages within a topic can come and go. Indeed, most topics define the lifetime of messages contained within that topic.</p> <p>Consider, for example, that we want to add a new module to an existing configuration that reports on the average number of uses of a certain button per month. In a traditional system, the data could be a challenge to create. Historical data may not even exist. But in SodaCan, the data already exists in the topic that was used to get the button press notification to the lamp that is controlled by that button press. (Just because the message was consumed by one module does not mean that the message will be discarded). So, the new reporting module simply subscribes to that same topic and it will get all of the messages from the past in chronological order.</p> <p>Now, SodaCan has several ways to deal with old messages in a topic. One can set an expiration date for a particular topic: Messages older than a certain number of days, weeks, months, or years will be automatically deleted. Or, when a topic exceeds a certain size, older messages can be deleted. Finally, one can just let the messages accumulate forever. Consider that many messages in a SodaCan application are quite small. Our button activation message will be about 50 bytes long. If we press that button 50 times per day, every day for a year, that would add up to less than one megabyte of data. Therefore, it's probably not worth cleaning up this type of message if there is even a small change of using that data in the future. On the other hand, messages from a security camera are much larger and so the topic should probably be purged either based on size (a very safe option) or the age of messages.</p>"},{"location":"languageGuide/#system-messages","title":"System Messages","text":"<p>The messaging system is also used for administrative and operational purposes. Any agent running a module or an adapter routes error messages to a log topic. SodaCan uses an administrative topic to deploy modules to the appropriate agent/server. Therefore, in a clustered setup, it is not necessary to manually keep application files on individual servers. By default, Module persistence is also kept in an administrative topic. </p> Topic Description xxx All mode commands are broadcast on this topic, see CLI for details module"},{"location":"languageGuide/#special-variables","title":"Special Variables","text":"<p>In addition to variables that you explicitly define in your module, some are special in that they provide access to the agent, system, or custom plugins.  Variables can also have attributes. Most special variables provide access to plugins. Some attributes are actually attributes on all variables. For example, a SUBSCRIBE variable provides access to when the message was created, which module (or plugin) sent it, etc.</p> <p>Special attribute names are preceded by a hash (#) symbol. for example, assuming the following is a SUBSCRIBE variable named \"mode\",  `mode.#msgid' will access the message id of the last message that set that variable. Those marked read are read-only. read/write attributes can be assigned to. Some are write only write.</p> <p>Note: A module variable is a variable defined in a module: publish, subscribe, private, or topic.</p> variable Attribute read/write Description any subscribe variable #timestamp read The timestamp (UTC Z-time) of the message any subscribe variable #msgid read The timestamp (UTC Z-time) of the message any subscribe variable #topic read The topic of the message any subscribe variable #namespace read The topic of the message any subscribe variable #version read The message format version any module variable #type read The type of variable (string, number, boolean, etc) any module variable #modified read True if modified in this cycle any module variable #initialValue read The initial value of the variable as declared any module variable #constraints read The constraints specified for this variable. any publish variable #modified read True if modified in this cycle and will be published at the conclusion of the cycle system.config #latitude read Latitude of this location system.config #longitude read Longitude of this location system.config #timezone read Timezone of this location system.config #locationName read Name of this location system.config #locationAddress read Address of this location system.clock #month read The month of the current datetime system.clock #day read The day of the current datetime system.clock #year read The year of the current datetime system.clock #hour read The hour of the current datetime system.clock #minute read The minute of the current datetime system.clock #second read The seconds of the current datetime system.clock #sunrise read Today's sunrise system.clock #sunset read Today's sunrise system.clock #season read The current season system.clock #season read Today's sunset system.log # info write Write informational text to system log system.log # warn write Write warning text to system log system.log # alert write Send general alert message and log it system.module #name read Name of this module system.module #eventType read message or clock event system.module #source read Current source code of module system.agent #name read Name of the agent hosting this module rpi4.gpio2 # mode read/write Set mode for GPIO 2 rpi4.gpio2 # pin read/write Set/get pin for GPIO 2 dmx.fixture2 #red write Set the red color value in (lighting) fixture2"},{"location":"languageReference/","title":"Sodacan Control (SCC)","text":"<p>A declarative language for controlling things.  The goal of this language is to be concise and to the extent possible declarative. </p>"},{"location":"languageReference/#general-lexical-rules","title":"General lexical rules","text":"<p>The SCC language is relatively simple. In fact, it is designed to be used by non-programmers. While tabs and whitespace improve human readability, they are ignored in the language. Should more complicated logic be needed, other languages such as Java or C++ can be used. Very few reserved words are needed for any particular statement. Each statement will be described below.</p> <p>SCC is line oriented with one statement per line. Therefore, line endings are significant.</p>"},{"location":"languageReference/#case-sensitivity","title":"Case Sensitivity","text":"<p>Key words are capitalized. User-created identifiers must be lowercase in order to avoid a possible conflict with keywords.</p> <p>&amp;&amp;&amp;&amp;This is simply a convention to aid readability. Statements, identifiers and other reserved words match regardless of case. <pre><code>    THEN\n    then\n    Then\n</code></pre> All mean the same thing. Likewise, identifiers are case insensitive ```LOCAL myIdentifer    ON myIdentifier    ON MYIDENTIFIER    ON myidentifier <pre><code>Are equivalent.\n\nQuoted strings, of course, retain the case as specified in the string. A string literal\n</code></pre>     \"Any string in a storm\" <pre><code>### Literal values and variables\nEnumerations are the most commonly used literals used to constrain a variable. For example:\n</code></pre>     PUBLIC state {off,on} <pre><code>describes a variable named 'state' and it has two possible values, `on` and `off`.\nThe braces are what identify the declaration of a variable as having having enumerated values.\n\nAn decimal variable is declared in either of these forms:\n</code></pre>     PUBLIC count 0     PUBLIC price 0.00 <pre><code>with the `0` or `0.0` being the initial value of the variable.\n\nA boolean variable is similar to an enumeration with the possible values limited to `true` and `false`.\n</code></pre>     PUBLIC available {false,true} <pre><code>Date and time literals are more complicated and are covered in a separate section, below.\n\nA string literal contains any alphanumeric characters. A variable containing a string must \nbe initialized with a string literal, even if the string literal is empty:\n</code></pre>     PUBLIC myName \"John\" <pre><code>Some variables have no value whatsoever. Such a variable is still quite useful. For example, if we declare a variable named\n`bedtime`, the variable can be **activated**. In other words, \"it's bedtime\". This causes that variable to be published as a message so that other modules can subscribe to it. Other than triggering an action, the message does not carry any other useful information.\n</code></pre>     MODULE topics         TOPIC myhouse.bedtime <pre><code>A simple button can be declared the same way:\n</code></pre>     MODULE livingRoomButton         PUBLIC active <pre><code>### Reserved Words\nThe following are reserved and recognized at the beginning of a line. Elsewhere, they are allowed as identifiers:\n\n | Word        | Description |\n | ----------- | ----------- |\n | MODULE      | Defines a module       |\n | AT          | Activates when the specified time occurs        |\n | PUBLIC | Declare a variable that will be published as its value changes.|\n | PRIVATE | Declare a variable that is only visible within a module |\n | ON | Activates when a variable (PUBLIC or PRIVATE) changes |\n | SUBSCRIBE | Declares an interest in messages from outside the module|\n\n### Comments\nComments begin with // and continue to the end of line\n```// A Comment\n    AT noon // Another comment\n    // AT midnight // This line of code is \"commented out\"\n</code></pre></p>"},{"location":"languageReference/#modules","title":"Modules","text":"<p>A module is, in essence, a way of specifying an intermediate name space. The next section covers the details of naming and scope.</p> <p>Unlike most other areas of the code, module names are case sensitive.</p> <p>The controller scans the directory or directories specified in the configuration for one or more <code>module</code> files with an extension of <code>.scc</code>. The name of the module must match the file name (not including the <code>.scc</code>). For example, if the module file is named <code>myModule.scc</code> then the module should have the name. <pre><code>    module myModule\n</code></pre></p>"},{"location":"languageReference/#naming","title":"Naming","text":"<p>Every item in a module has a name. For example, the <code>test</code> module has a variable named <code>level</code>.  <pre><code>MODULE test\n    PUBLIC level 0.0\n    ...\n</code></pre> Surrounding all of this is a domain name that names the system containing the modules. This name is used as a namespace name, not a specific bit of hardware or software. However, it can be used to name a messaging broker which does usually run on a single computer or a cluster of computer. </p> Scope Description domain A server or cluster of servers module A module variable name An individual variable within a module <p>The domain scope is intended to be globally unique. However, in a small setup, this requirement can be relaxed so that the domain is something simple like <code>MyHouse</code>.  Such a simple name would be inappropriate if, for example, two houses (properties) could communicate with each other (for example, property owner A knows if property owner B's garage door is open or not and if so to delay turning on his lawn sprinklers).</p> <p>The module scope means any variable contained in that module is implicitly named by the module. So, a variable such as <code>state</code> within the <code>lamp1</code> module which is part of the <code>net.sodacan.scc</code> domain has the full, globally unique, name of <code>net.sodacan.scc.lamp1.state</code>.</p> <p>Within the <code>lamp1</code> module, the name <code>state</code> is sufficient. And, within the <code>net.sodan.scc</code> domain, <code>lamp1.state</code> is sufficient. In fact, the domain should only be used sparingly. The system will add and remove the outer name scopes as needed. Of course if within a module you subscribe to a variable outside of your local domain, the the full name must be specified.</p> <pre><code>    SUBSCRIBE my.neighor.garageDoor.state {on,off}\n</code></pre> <p>Notice that the enumeration constraint is specified on the subscription above even though it is your neighbor that defines the state variable. This restatement of the constraint is used to help ensure that the module is correct during compilation even if the neighbors system is not, yet, operational.</p> <p>Two or more modules within the same domain, such as a lamp and the button that controls it can (and should) dispense with domain names completely. In the following two modules, a message from button1 is subscribed to by the <code>lamp1</code> module. </p> <pre><code>    MODULE lamp1\n        SUBSCRIBE button1.press // This subscribes to button1.press\n        PUBLIC state\n        ON button1.press\n          AND state==off\n          THEN state=on\n        ON button1.press\n          AND state==on\n          THEN state=off\n\n    MODULE button1\n        PUBLIC press\n        PRIVATE pin2\n        ON pin2==true\n          THEN activate(press)  // This publishes button1.press\n        ...\n</code></pre>"},{"location":"languageReference/#asynchronous","title":"Asynchronous","text":"<p>In a request-response architecture, one module needing some bit of data typically issues a request and waits for a response from another module. In SodaCan, this process is reversed by using a publish-subscribe approach.</p> <p>In the previous example, notice that button1 makes no mention of lamp1. In other words, button1 only published information about the button press (the activate function call). But it doesn't put a destination on the message.  The name of the message is <code>ourDomain.button1.press</code>. The <code>lamp1</code> module then subscribes to  that message. The module responds to that message in the <code>ON</code> statement(s). The interesting part of this approach is that either of these modules could be written and tested before the other even exists. Furthermore, there is no technical constraint as to the mechanism used to deliver the message from the sending module to the receiving module. For example, the two modules could be on completely different computers. </p> <p>Any number of modules (including none) can subscribe to the same message and react how it sees fit. The following is a simple bedtime button setup. Any lamp participating in the bedtime event initiated by the bedtime button does something, usually to turn itself off although some could turn it on as well.</p>"},{"location":"languageReference/#topics","title":"Topics","text":"<p><pre><code>    MODULE bedtime\n        PUBLIC activate\n        PRIVATE pin2\n        ON pin2==true\n          THEN activate(activate)   // This publishes button1.press\n        ...\n\n    MODULE lamp1\n        SUBSCRIBE bedtime.activate  // This subscribes to button1.press\n        PUBLIC state\n        ON bedtime.activate\n          THEN state=off            // Turn off this light\n</code></pre> Now, the name of <code>bedtime</code> module is a little restrictive. It assumes that there is only one source of the bedtime message which is in the bedtime(button) module. If we had a phone app that could initiate bedtime, we would want it to generate the same message. So, to make this setup more flexible we ignore the lamp1 module name and name a neutral <code>topic</code> which will carry the message. This is what the button module looks like now:</p> <p><pre><code>    MODULE bedtimeButton\n        PUBLIC activate AS bedtime\n        PRIVATE pin2\n        ON pin2==true\n          THEN activate(activate)   // This publishes bedtime\n        ... \n</code></pre> Notice that we changed the name of the module to be more descriptive ie <code>bedtimeButton</code> and modified  the declaration of the activate variable to use the alias <code>AS bedtime.activate</code>.</p> <p>It is important to point out a restriction in this setup: when a public variable uses the <code>AS</code> clause,  it could, in theory, spoof another module. Or, it could name a topic that has not been defined.  To prevent this from happening, a simple check is made that prevents an alias from naming an  existing module other than itself. In the above example, there should be no module named 'bedtime' and there isn't  but how can we be sure that <code>bedtime</code> is reserved so that a future module doesn't use that name?</p> <p>Reserve the name (<code>bedtime</code> in this case) using a TOPIC definition. A topic is a channel for messages to be exchanged. Each <code>PUBLIC</code> variable defines a topic and each <code>SUBSCRIBE</code> statement subscribes to a topic. This new topic, <code>bedtime</code>, is defined explicitly in a <code>TOPIC</code> declaration. In most respects, it is the same as a <code>PUBLIC</code> declaration. The main difference is that the name of a topic does not include the name of the module. By convention, a module that declares one or more topics should not contain any other type of statement.</p> <pre><code>    MODULE topics\n        TOPIC bedtime.activate\n        TOPIC ...\n</code></pre> <p>When a variable is published or subscribed to, SCC can validate that the name is contained in either a module name or a topic name.</p>"},{"location":"languageReference/#statements","title":"Statements","text":"<p>One statement per line. Empty lines are ignored.</p> Statement Parent Statement module - topic module subscription module private module public module at module on module with at,on then at,on"},{"location":"languageReference/#module-statement","title":"Module Statement","text":"<p>Module...</p>"},{"location":"languageReference/#topic-statement","title":"Topic Statement","text":"<p>A topic</p>"},{"location":"languageReference/#subscription-statement","title":"Subscription Statement","text":"<p>A subscription declares an interest in a particular type of message. \"When you send it, I want to receive it.\"</p>"},{"location":"languageReference/#public-statement","title":"Public Statement","text":"<p>A public variable will automatically be published when it changes.</p>"},{"location":"languageReference/#private-statement","title":"Private Statement","text":"<p>A private variable is...</p>"},{"location":"languageReference/#at-statement","title":"At Statement","text":"<p>With the passage of time, the <code>AT</code> statement determines if it is interested in the current time (now). For example, <pre><code>    AT Noon\n        THEN ...\n</code></pre> means that at noon on any particular day, something should happen. In other words, the attached <code>THEN</code> will be executed.</p>"},{"location":"languageReference/#on-statement","title":"On Statement","text":"<p>The <code>ON</code> statement reacts a specific message that the module subscribed to. <pre><code>    ON bedtime\n      THEN ...\n</code></pre></p>"},{"location":"languageReference/#with-statement","title":"With Statement","text":""},{"location":"languageReference/#then-statement","title":"Then Statement","text":""},{"location":"languageReference/#when-statement","title":"When Statement","text":""},{"location":"operations/","title":"Operations Guide","text":""},{"location":"operations/#deployment-modes","title":"Deployment Modes","text":"<p>When its time to roll out a new or updated module, you might want to do a final test on the live system without affecting the live system. To do this, the soda command line tool can be used to initiate a \"copy\" of the current (default) mode to a separate mode probably named something like \"test-new-light-control\". But we'll use \"test3\" in the examples below.</p> <p>The copy operation is comprehensive. In particular, topics use the same name as before with the mode name appended. Modules are also renamed with the mode appended to the module name. </p> <p>To aid in development and testing, a mode can also have a manually operated clock rather than a real-time clock. A new mode starts life with a frozen clock set at a time that is unrealistic. Therefore, any module that reacts to time events will not activate.</p> <p>For normal operation, the clock for a mode is normally set to \"live\". That is, the time base used to determine when an <code>AT</code> statement is triggered by the passage of time of the actual wall-clock.  This can be done with the soda command-line tool:</p> <p><pre><code>  soda mode clock test3 live\n</code></pre> However, for testing or debugging, a live clock is not very helpful. Let's say it's July and you want to test a module that does something on new year's day. You don't want to wait until January to test it and changing the system clock is not a good idea. </p> <p>In the command-line tool, you can manually control the clock for a given mode. In the following, we set the clock to midnight on new year's day in our testing mode.</p> <p><pre><code>  soda mode create test3\n  soda module deploy test3 myNewModule\n  soda clock test3 1-jan-2024 00:00\n</code></pre> In this manual mode, the clock is only advanced when you set the clock to a different time.</p>"},{"location":"operations/#sodacan-configuration","title":"SodaCan Configuration","text":"<p>Each SodaCan agent needs a configuration file which, at a minimum determines how to connect to the message bus.</p> <p>The Web Server also needs a configuration which, in addition to the above, specifies which port to listen on for the RESTful API.</p>"},{"location":"operations/#kafka-configuration","title":"Kafka Configuration","text":"<p>Port usage</p> <p>Broker ID should be non-zero for distributed</p> <p>Producer linger setting should be set to 0ms. This application is more about responsiveness than throughput.</p>"}]}